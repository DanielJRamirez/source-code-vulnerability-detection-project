# Code2vec for Source Code Vulnerability Detection: dx2021 implementation
## Disclaimer: This method, in its entirety, was created by David Coimbra in an attempt to implement the techniques of "On using distributed representations of source code for the detection of C security vulnerabilities"
## Source Repository: https://github.com/dcoimbra/dx2021
## Source Paper: https://arxiv.org/abs/2106.01367

## Getting Started

1. Install prerequisites

* tensorflow
  ```sh
  pip install tensorflow
  ```

2. Clone the repo
   ```sh
   git clone https://github.com/DanielJRamirez/source-code-vulnerability-detection-project.git
   ```
   
3. Enter the correct directory
   ```sh
   cd code2vec-implementation
   ```

## Optional Step
If the code is going to be run on a Windows system, run the following commands to convert the directories into a useable format.
   ```sh
   cd astminer
   find . -type f -print0 | xargs -0 dos2unix
   cd ../code2vec
   find . -type f -print0 | xargs -0 dos2unix
   cd ..
   ```

## Extract path-contexts
The data is in the `astminer/dataset` folder. The dataset is already split into three .jsonl files, for training, validation and testing.

1. Compile `astminer`
   ```sh
   cd astminer
   ./gradlew shadowJar
   ```

2. Extract path-contexts for each dataset split. It will take some time.
  ```sh
  ./cli.sh test
  ./cli.sh valid
  ./cli.sh train
  ```
  
Path-contexts will be extracted into the `code2vec` folder, into the files `devign.train.raw.txt`, `devign.test.raw.txt`, `devign.valid.raw.txt`.
These steps will each also generate the following warning followed by a series of lines about a subsequent Java exception:
  ```sh
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
  ```
This is fine and to be expected.
  
## Train the model

1. Preprocess the data into the code2vec format
  ```sh
  cd ../code2vec
  source preprocess.sh
  ```
  
2. Train
  ```sh
  ./train.sh
  ```
  
 ## Evaluate the model
 1. Once the F1 score on the validation set stops improving over time, you can choose from iterations (limited to iterations 11-16 on some systems) that performed the best on the validation set. Suppose that iteration #11 is our chosen model.
 
 2. Release the model
  ```sh
   python3 code2vec.py --load models/devign/saved_model_iter11 --release
  ```
 
 3. Run the evaluation script on the test data
  ```sh
  python3 code2vec.py --load models/devign/saved_model_iter11.release --test data/devign/devign.test.c2v
  ```
 
 ## Generating CodeXGLUE predictions
 Generates a predictions file as described in the [CodeXGLUE repository for the defect detection task](https://github.com/microsoft/CodeXGLUE/tree/main/Code-Code/Defect-detection).
 ```sh
 python prediction_outputter.py --load models/devign/saved_model_iter11.release # or your chosen iteration
 ```
 This will generate predictions for the test set. To generate predictions for the validation set, edit `prediction_outputter.py` and modify the global variables accordingly. 
 
Note: the completion of this step may require the following steps to be run beforehand:
  ```sh
  cd ../astminer
  ./cli.sh test
  cd ../code2vec
  ```

## Acknowledgements from David Coimbra
This work was supported in part by Fundação para a Ciencia e a Tecnologia (FCT) under Grants CMU/TIC/0064/2019 (a project funded by the Carnegie Mellon Portugal Program) and UIDB/50021/2020.
